# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt
extends c

##
## Preprocessor
# #include <...>
snippet incb
#include <bits/stdc++.h>
endsnippet

snippet incc
#include <${0:iostream}>
endsnippet

##


## STL Collections
# std::array
snippet array
array<${1:T}, ${2:N}> ${0}
endsnippet

# std::vector
snippet vector
vector<${1:T}> ${0}
endsnippet

# std::deque
snippet deque
deque<${1:T}> ${0}
endsnippet

# std::forward_list
snippet flist
forward_list<${1:T}> ${0}
endsnippet

# std::list
snippet list
list<${1:T}> ${0}
endsnippet

# std::set
snippet set
set<${1:T}> ${0}
endsnippet

# std::map
snippet map
map<${1:K}, ${2:V}> ${0}
endsnippet

# std::multiset
snippet mset
multiset<${1:T}> ${0}
endsnippet

# std::multimap
snippet mmap
multimap<${1:K}, ${2:V}> ${0}
endsnippet

# std::unordered_set
snippet uset
unordered_set<${1:T}> ${0}
endsnippet

# std::unordered_map
snippet umap
unordered_map<${1:K}, ${2:V}> ${0}
endsnippet

# std::unordered_multiset
snippet umset
unordered_multiset<${1:T}> ${0}
endsnippet

# std::unordered_multimap
snippet ummap
unordered_multimap<${1:K}, ${2:V}> ${0}
endsnippet

# std::stack
snippet stack
stack<${1:T}> ${0}
endsnippet

# std::queue
snippet queue
queue<${1:T}> ${0}
endsnippet

# std::priority_queue
snippet pqueue
priority_queue<${1:T}> ${0}
endsnippet
## 


## STL smart pointers
# std::shared_ptr
snippet msp
shared_ptr<${1:T}> ${2} = make_shared<$1>(${3});
endsnippet

snippet amsp
auto ${1} = make_shared<${2:T}>(${3});
endsnippet

# std::unique_ptr
snippet mup
unique_ptr<${1:T}> ${2} = make_unique<$1>(${3});
endsnippet

snippet amup
auto ${1} = make_unique<${2:T}>(${3});
endsnippet
##


## Access Modifiers
# private
snippet pri
private
endsnippet

# protected
snippet pro
protected
endsnippet

# public
snippet pub
public
endsnippet

# friend
snippet fr
friend
endsnippet

# mutable
snippet mu
mutable
endsnippet
##


## Class
# class
snippet class
class 
{
	public:
		$1(${2});
		virtual ~$1();

	protected:
		m_${5}; /*!< ${6:Member description} */
};
endsnippet

# namespace
snippet ns
namespace ${1:name} {
	${0}
} /* namespace $1 */
endsnippet

snippet ans
namespace {
	${0}
}
endsnippet
##

## Input/Output
# std::cout
snippet cout
cout << ${1} << ${2:endl}
endsnippet

# std::cin
snippet cin
cin >> ${0}
endsnippet
##


## Casts
# static
snippet sca
static_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
# dynamic
snippet dca
dynamic_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
# reinterpret
snippet rca
reinterpret_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
# const
snippet cca
const_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
##


## Iteration
# Default for loop
# Empty for loop
snippet for "Empty for loop"
for(${1}) {
	${0}
}
endsnippet

# for i
snippet fori
for(int ${1:i} = ${2:0}; ${3}; ${4:++}$1) {
	${0}
}
endsnippet

# foreach
snippet fore
for(${1:auto} ${2:i} : ${3:container}) {
	${0}
}
endsnippet

# iterator
snippet forit
for(${1:vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
	${0}
}
endsnippet

# auto iterator
snippet forai
for(auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
	${3:cout << *$1 << endl;}
}
endsnippet

snippet forbe "general for loop (general for)"
for(${6:auto} ${1:i} = ${2:v.begin()}; `!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` ${4:!=} ${3:`!p m = re.search(r'^(?:(.*)(\.|->)begin\(\)|((?:std|boost)::)?begin\((.*)\))$', t[2]); snip.rv = (((m.group(3) if m.group(3) else "") + "end(" + m.group(4) + ")") if m.group(4) else (m.group(1) + m.group(2) + "end()")) if m else ""`}; ${5:++`!p snip.rv = t[1].split(" ")[-1]`}) {
	${VISUAL}$0
}
endsnippet

snippet while "Empty while loop"
while(${1}) {
	${0}
} 
endsnippet

snippet dowhile "do while"
do {
	${0}
} while(${1})
endsnippet

snippet all "$1.begin(), $1.end() (begin to end)"
${1:v}.begin(), $1.end()
endsnippet

snippet rall "$1.rbegin(), $1.rend() (reverse begin to reverse end)"
${1:v}.rbegin(), $1.rend()
endsnippet

snippet begin "$1.begin()(begin)"
${1:v}.begin()
endsnippet

snippet end "$1.end() (end)"
${1:v}.end()
endsnippet

snippet rbegin "$1.rbegin() (reverse begin)"
${1:v}.rbegin()
endsnippet

snippet rend "$1.rend() (reverse end)"
${1:v}.rend()
endsnippet
##


## Lambdas
# lamda (one line)
snippet ld
[${1}](${2}){${3}};
endsnippet
# lambda (multi-line)
snippet lld
[${1}](${2}){
	${3}
};
endsnippet

## Utils
# snippets exception
snippet try
try {

}catch(${1}) {

}
endsnippet

# auto function
snippet af 
auto ${1:name}(${2}) -> ${3:void}
{
	${0}
};
endsnippet

# main(void)
snippet mainn "main(void)"
int main(void) {
	${0}
	return 0;
}
endsnippet
